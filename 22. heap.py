# 힙이란?
# 1. 최대힙
# 키값이 가장 큰 노드를 찾기 위한 자료구조
# 조건 : 완전 이진트리여야함 / 부모노드 키값 > 자식노드 키값
# 루트노드는 키값이 가장 크다.

# 2. 최소 힙 
# 키값이 가장 작은 노드를 찾기 위한 자료구조
# 조건 : 완전 이진트리여야 함 / 부모노드 키값 < 자식노드 키값
# 루트 노드는 키값이 가장 작다.

# 힙 의 삽입연산 - last라는 인덱스를 이용해야 한다.
'''
서로 다른 100개의 정수가 키(n)로 입력된다.
'''
# 이때 키(n)를 삽입하면서 최대힙을 만드는 함수
def enq(n):
    global last
    last += 1
    tree[last]= n
    c = last
    p = c // 2
    while p > 0 and tree[p] < tree[c]:
        tree[p], tree[c] = tree[c], tree[p]
        c = p
        p = c // 2

tree = [0] * 101
last = 0

# 최대힙에서 삭제를 구현해보자
# 삭제는 항상 루트에서만 이루어진다.
# 인덱스(노드번호)와 키값을 구분 잘하자

# 최대힙에서 루트 삭제하는 함수
def deq():
    global last
    tmp = tree[1] # 루트의 key값을 tmp에 저장
    tree[1] = tree[last]  # 마지막 노드의 키값을 루트 노드에 복사(자리를 올려준다.)
    last -= 1 # 마지막 노드를 재설정(삭제) 해준다. (삭제와 비슷한 효과 / 실제로 삭제는 아님)
    # 부모 키 값 > 자식 키 값인지 확인 - 최대힙 유지
    p = 1
    c = p * 2  # 왼쪽 자식을 구하는 공식 / 현재 자식으로 왼쪽자식을 선택한 상태
    while c <= last: # 왼쪽 자식이 있으면 / 오른쪽 자식은 무조건 있다.
        if c + 1 <= last and tree[c] < tree[c+1]:  # 오른쪽 자식도 있고 오른쪽 자식의 키값이 더 크면
            c += 1  # 오른쪽 자식을 선택
        if tree[p] < tree[c]:
            tree[p], tree[c] = tree[c], tree[p]
            p = c  # 현재 선택된 자식을 새로운 부모로 보고 / 자리가 바뀐 곳의 최대힙 유지 여부를 따져보기 위해서
            c = p * 2  # 그 자식을 본다.(공식)
        else:
            break
    return tmp  # 삭제한 루트의 키값을 쓰기 위해서 그것을 return해준다.



# 포화이진트리의 노드번호 1 ~ 100
tree = [0] * 101
last = 0  # 마지막 노드 번호가 처음에는 0이다가 노드가 하나씩 생성될 때마다 1씩 증가
